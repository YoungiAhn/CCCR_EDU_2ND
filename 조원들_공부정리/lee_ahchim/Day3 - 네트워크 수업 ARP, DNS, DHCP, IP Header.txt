오늘은
뭘 퀴즈했냐면
1. OSI 7 Layer
2. 멀티 액세스 프로토콜
3. 서브넷팅 문제 하나 풀었음
4. NAT

매일 복습 한번씩 합니다.

MAC 앞 24비트는 제조사
    뒤 24비트는 제품번호

LLC
모든 LAN 은 802 표준에 의해 똑같은 LLC 계층을 가진당
Physical 계층의 다른 말 같은데?


ARP 프로토콜이 어떤 흐름으로 진행되고 있는지

공인 아이피는 클래스와 상관이 없다

사설 IP - 네트워크를 벗어나면 사설 IP를 그대로 사용을 못하는것이지.
그래서 NAT 쓰는거지.

공인 IP로 나가는데 돌아올 때 다시 사설 아이피로 분류하기 위해 포트 번호를 붙여서 사용
크롬 창도 여러개(네이버구글다음)인데 충돌나지 않는 이유는 프로세스 포트 번호가 다르기 때문..


- ARP (Address Resolution Protocol)

  ㅇ 논리적인 IP 주소를 (망계층), 물리적인 MAC 주소로 (데이터링크 계층),  
     바꾸어주는 역할을 하는 주소 해석 프로토콜


구글 웹서버 내 컴퓨터에서 가기 위해서는 (외부 네트워크로 접속하고 싶으면)
1. 내 컴퓨터 IP는 아는데 구글 웹서버 IP는 모름.
2. DHCP 서버에서 DNS 서버의 IP를 받아옴.*** 생각해보니 그렇구나. 모든 IP를 부여해주고 알려주니까. 게이트웨이 주소 등도... DNS 주소 동적으로 받아오잖아. 설정창에서
- DHCP

  ㅇ 네트워크상에서 동적으로 IP 주소 및 기타 구성정보 등을 부여/관리하는 프로토콜
- DHCP 주요 구성정보(매개변수) 및 동적 할당 

  ㅇ 구성 정보
     - 기본 정보 : ① IP주소, ② 서브넷 마스크, ③ 디폴트 게이트웨이
     - 추가 정보 : ④ 네임서버(DNS)의 IP주소, 홈 에이전트, 디폴트 도메인 네임 등

DNS 이란? 

  ㅇ 호스트에 대한 이름 주소(도메인 주소) 변환을 위한 서버- 분산 데이터베이스시스템

네트워크 계층에서 DHCP, DNS 과정이 이루어진다.
프로토콜은 7계층에 있긴한데

3. DNS 서버에서 구글 IP를 받아오면 내 IP 적고 목적지 IP 주소로 적음.
4. 내꺼랑 목적지의 맥주소를 적음. 아직 구글 맥주소는 알 수 없으니 게이트웨이 것을 적는데, 
   게이트웨이의 맥주소도 물어봐야 알 수 있음.(전송 - FF:FF:FF:FF:FF:FF)
-- ARP가 ARP Query를 보내서 게이트웨이의 맥주소를 알아옴. 그리고 IP 와 대응해서 적음. (3계층)
   ARP Query에 SRC IP, DST IP를 적고 패키징 한다음,  겉면에 Type 정보(ARP다 정도)를 적고 SRC MAC, DST MAC(FF:FF:FF:FF:FF:FF) 적음 (2계층)
5. 테이블에 적고 나면 다음부터(돌아올때부터)는 브로드캐스트로 통신하지 않고 유니캐스트로 통신.
스위치는 아이피로 맥주소를 알 수 없다. 스위치는 포트와 맥주소만 대응해서 이런 과정이 있는 것!
->
ARP Query를 보내고, ARP Response를 받음.
맥주소, 타입지정 등...

마지막으로 게이트웨이 1의 맥주소를 적을 것이다.

-----------------------------------------------------


이러한 정보를 저장해놓는 테이블 -> 호스트 A의 포워드테이블. Forward Table

A의 Forwarding Table
------------------------
외부 IP	| Gateway IP
------------------------
...
------------------------
Forwarding Table은 라우팅 테이블에 속하는 테이블이다!


A의 ARP Table
------------------------
IP	| MAC
------------------------
G.W IP	| G.W MAC
...	| ...
------------------------

RARP : ARP 과정을 반대로 수행 - MAC 주소를 IP 주소로 바꾸어 줌
사실 안 쓴다. 쓸일이 업떠...

ARP와 스위치 포워딩 테이블은 유사점이 있지만 다른 친구들이다.


arp -a
_gateway 맥주소 나옴!

랜선 뺐다가 다시 꼽으면
게이트웨이 맥주소 알아와!
해서 ARP 테이블에 뜹니다...


DHCP 서버는 내부네트워크 스위치에 물려있다.

내가 게이트웨이야 라고 게이트웨이가 계속 이야기하면 ARP Spoofing 막을 수 있다 뿌슝빠슝
트래픽 낭비아닌가 ㅋㅋㅋㅋㅋㅋ

root@user-Aspire-E5-576:~# route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         210.117.126.1   0.0.0.0         UG    100    0        0 enp3s0f1
169.254.0.0     0.0.0.0         255.255.0.0     U     1000   0        0 enp3s0f1
210.117.126.0   0.0.0.0         255.255.255.192 U     100    0        0 enp3s0f1
root@user-Aspire-E5-576:~# netstat -r
Kernel IP routing table
Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
default         _gateway        0.0.0.0         UG        0 0          0 enp3s0f1
link-local      0.0.0.0         255.255.0.0     U         0 0          0 enp3s0f1
210.117.126.0   0.0.0.0         255.255.255.192 U         0 0          0 enp3s0f1


도메인명~IP~후후~

DHCP 동작 과정
(ex. 2.2.2.2)
DHCP				HOST
	  	    <-		IP : X
		DHCP Discover	src : X
	  	<-		dest : 255.255.255.255:67 (DHCP 위치도 모르니깐. 포트번호 67만 이 포트를 열어 놓으니까 DHCP만 대답할 것이다.)
    				ID : 5 (돌아올때 보낸 호스트인지 모르니까 본인이 식별번호를 실어 보내는 것)
dst : 255.255.255.255:68
src : 2.2.2.2
ID : 5
		->
			->	IP : X (아이피를 받을 준비를 했다)
				src : X
		DHCP Offer	dst : 255.255.255.255:67
				ID : 5
				(이 짓을 하는 이유 : DHCP 서버가 여러개 있을 수도 있으니까, 얘한테 받을거라고 공표)

		DHCP Request
			<-
		<-
ACK 메세지를 날림
(IP와 서브넷마스크, 
게이트웨이, DNS 주소 을 실어날림)
		->
			->
		DHCP ACK
				그럼 호스트에서 정보를 받고 통신준비 완료

UDP 포트 번호 67은 서버의 대상 포트 
클라이언트의 UDP 포트 번호 68

pg 37
73,74

공인되지 않은 DHCP 서버
      "       DHCP 클라이언트

Header Checksum 오류 판별 과정
1) 체크섬 제외 16진수 변환
2) 모두더한다.
3) | 645C
   ->645C+1 = 645D
4) FFFF-645D
   =9BA2
5) 비교해서 확인


세그먼트 쪼개기
[---------------]
4000바이트 ID = A flag = 0 
헤더 20바이트
3980바이트
1. 1480바이트 (헤더 뗀 사이즈)
2. 1480바이트
3. 1020바이트
1480바이트: MTU 사이즈 - TCP의 경우 MTU(기본 최대 전송 단위)가 1500바이트로 설정

MTU:1500
헤더를 짤라버렸으니! (툭 하고)
헤더를 다시 세그먼트 하나하나에 다 달아줌.
1. Identifier = A 	flag = 1	offset = 0
2. Identifier = A	flag = 1	offset = 160
3. Identifier = A	flag = 0	offset = 320

=> 계산방법
flag - 뒤에 데이터 있어? 없어?

offset - 짤린 데이터 크기를 8로 나눈 것
[--------------]
  |   |    |
  0  1480 2960
0, 1480/8, 2960/8
0, 160, 320
(헤더가 늘어나는 크기가 8바이트씩이라서 8로 나누는 것.)


조립
P - Packet
 |1P  	  2P	 3P|
 -------------------
0		    3
헤더가 사라지고 원래 있었던 데이터대로 다시 3980바이트가 됨.
헤더 떼야 디캡슐레이션이 되니까...


Flags 상세표현
0 - 0 (비워두는것, 안 씀)
1 - DF : Don't Fragment. 여기까지 자르자... 이런의미...
2 - MF : 더 있으면 1이고 끝이면 0 표기 (More Fragment)
(Flag는 이렇게 쓰도록 그냥 약속되어 있음)



